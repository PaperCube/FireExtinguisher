# “灭火”Arduino机器人示例与接口解释
*版本v7.26.1*  

## 描述
本程序库是FIRA灭火机器人筑柏2019款的配套程序库。此机器人使用了多个传感器与运动部件，故引入本库简化机器人的使用

--------------------

## 开始使用本库
请在[此处](https://github.com/PaperCube/FireExtinguisher) (`github.com/PaperCube/FireExtinguisher`)下载本类库的所有文件，然后打开Arduino安装目录下的libraries文件夹，将所有文件放置到libraries文件夹中的一个文件夹内。例如，如果你新建一个名为`____FireExtinguisher`的文件夹，则你应该把所有文件放到`{Arduino安装目录}/libraries/____FireExtinguisher`文件夹中，并且如果你打开这个文件夹，你会看到大量的C++头文件和源代码。  
请在主程序中加入`#include "robot.h"`来使用本类库。

--------------------

## 设置你的机器人
在使用机器人的任何功能前，请先设置你的机器人。你需要完成下面两步才能设定你的机器人：
* 声明`robot`对象
* 设置传感器编号
* 调用**机器人的**`setup()`函数

### 步骤1 - 声明`robot`对象
声明`robot`对象是为了打开软件与硬件沟通的大门。我们一切操作都将在`robot`对象上进行。你只有在声明了`robot`对象之后才能使用它。因此我们应该尽量靠前声明，例如在所有include语句之后。

### 步骤2 - 设置传感器编号
假如我们上一步声明了`robot r`，则我们应该对`r`进行操作。我们应该调用`r.set_sensors(...)`来设置传感器的标号。我们可以在其中填写8个数，这8个数对应某个传感器所插的主板上的模拟端口。其中，当我们所面向的方向与车的前方面向的方向一致时，它们分别对应
1. 面向前方，位置靠左的传感器
2. 面向左侧，位置靠前的传感器
3. 面向左侧，位置靠后的传感器
4. 面向后方，位置靠左的传感器
5. 面向后方，位置靠右的传感器
6. 面向右侧，位置靠后的传感器
7. 面向右侧，位置靠前的传感器
8. 面向前方，位置靠右的传感器

例如，如果上述传感器恰好按上述顺序插到了1,2,3,4,5,6,7,8号模拟端口，则你应该写：
```
r.set_sensors(1,2,3,4,5,6,7,8);
```

### 步骤3 - 调用机器人的`setup()`函数
只需一句话：`r.setup()`  
但是请确保你在调用这句话之前你的机器人已经设置完毕传感器编号。

--------------------

## 使你的机器人行进
让机器人行进分为两步：
- 指定前进方向
- 通知机器人前进

指定机器人方向可以通过`r.set_direction([1个参数])`来完成。参数是方向，可以填写0，1，2，3，分别是前、左、后、右。

通知机器人行进可以通过`r.go([0~1个参数])`来完成。如果`r.go()`中不填写参数，则其效果与执行`r.go(100)`没有区别，其中100是机器人运行的速度。调用一次，永久有效（直到你更改它）。  

设置方向前，你并不一定要让它停下来。因为`r.set_direction(...)`本身也会先让他停止，然后再在另一个方向上恢复速度。这在高速运动时会导致打滑/漂移。

要让机器人停止，请`r.stop()`

机器人运行的速度取决于机器人的**电量**，方向以及你所设置的机器人的功率。你可以更改机器人运行的功率，功率越大，则机器人在相同的速度**值**下（也就是`r.go(...)`中填写相同的数时）具有越快的**实际**速度。你可以调用`r.set_max_power([1个参数])`来更改，其中的一个参数应该填写机器人的功率，取值范围为0~255。调用一次，永久有效（直到你更改它）。

在实际情况中，我们的各个电机运行的速度是不同的，即使其功率和速度值完全相同。在这种情况下，我们需要为每个电机设定不同的运行功率。你可以在`r.set_max_power(...)`中填写4个参数，分别代表前方，左侧，后方，右侧电机的功率。你可以通过实验来找出当这4个数分别是多少时，你的各个轮子的实际运行速度大致相同。调用一次，永久有效（直到你更改它）。

并且，在实际情况中，我们的电机在反向运行时会比正向运行时慢。因此，我们可以执行`r.reverse_power_ratio([4个小数])`来设置当我们的电机反向运动时提供的功率倍数。其参数对应的电机也是分别为前方，左侧，后方，右侧。例如，如果你全填写1.2，则你的所有电机在反向运作时都会以原本功率的1.2倍运行，以**尝试达到与正转相同的速度**。你需要实验才能得到一个合适的值。调用一次，永久有效（直到你更改它）。

电量不足时，机器人的主控板会重启，这对其正常运行是致命的问题。如果你想测试你的机器人是否具有可以维持运行的电量，你可以执行`r.__test_power()`。你的机器人会缓慢加速（因此建议你用手拿着它，不要让它在地面上跑出去）机器人蜂鸣器每短响一声，代表机器人的功率升高了10。每长响一声代表机器人功率升高了50。机器人功率最高是255，所以你最多只需要观察它直到它第5次长响。  
一般来说，如果它功率到了200仍然没有重启，我们就可以认为电量足够。如果它在功率到了200之前就重启了，请尽快更换电池。

### 单独控制某个电机 [New]

你可以调用`r.drive([2~3个参数])`来单独控制某个电机。  

对于2个参数的版本，第一个参数是指定哪个电机，0-3分别代表前、左、后、右，第二个参数是速度。左右两个电机速度值为正的时候会向前，前后两个电机则会向右。

对于3个参数的版本，第一个参数仍然是指定哪个电机，但是第二个参数则代表让这个电机向哪个方向运行。方向仍然是0-3分别代表前、左、后、右。第三个参数是速度。速度的符号不会被忽略。

建议通过`r.stop()`来停止。

### 旋转
你的机器人可以爱的魔力转圈圈。它有“一次调用，永久有效”模式和“计时”模式。
`r.rotate_at([1个参数])`可以使之旋转，其中填写的参数代表速度。大于0的数代表顺时针，小于0的数代表逆时针，并且调用一次，永久有效（直到你更改它）。  
`r.rotate_timed([2个参数])`可以使之旋转特定时长，经过这段时间后它就停止。第一个参数是速度，第二个参数是时间（毫秒）。

**很明显，上述使机器人运动的所有函数，无论是前进、停止、各种设定，还是旋转，都需要在`r.setup()`之后运行。**

### 校正
你的机器人可以以某个方向的平面为参照进行姿态校正。只需要调用`r.fix([1个参数])`就可以。其中填写一个方向，用于指定以什么平面进行参照。  
**但是这个并不是完美的**，有时它甚至不够可靠，尤其是你的距离比较远或者你偏移的角度比较大时。在2019年7月26日本函数获得了更新，但是仍然可以通过`r.fix_old`访问旧版校正函数。

`CALIBRATION_ACCURACY`定义了校正的准确度，`CALIBRATION_ROTATION_SPEED`定义了机器人旋转的速度，也就是校正的速度。速度越快则越不稳。

**很明显，校正函数需要在`r.setup()`之后运行。**

## 智能行进
只需执行`r.go_smartly()`即可智能行进。实际上它很不智能。如果`GO_LEFT_RIGHT_FIRST`是`true`则机器人先左右行进，如果`GO_RIGHT_FIRST == true`则机器人只会向右走，如果`GO_FORWARD_FIRST == true`则机器人只会向前走。你可以通过对它们赋值来更改智能行进的逻辑。

**你可以在任何时候更改这些值，但是`r.go_smartly()`之前设置的值才有效**

--------------------

## 操纵方向
操纵方向可以利用3个自带的函数`left_of`,`right_of`和`opposite`，分别代表某个方向的左侧方向，右侧方向和反向。它们都仅接受一个参数，返回一个值。例如，`opposite(3)`的值是`1`。

--------------------

## 读取机器人上的传感器
你可以使用`r.read_sensor([1~2个参数])`来读取传感器的值。第一个参数是方向，同样是0~3分别代表前、左、后、右。由于我们每个方向上有两个传感器，因此这样读出来的是综合的结果，是两个传感器数值的平均值。要获得其中一个的读数，你也可以填写两个参数，第一个是方向，第二个是指定具体哪一个。如果你把需要读的传感器面对的方向朝向你的前方，则第二个参数填写-1可以获得左侧的那一个，填写1可以获得右侧的那一个。  
例如:
```cpp
robot r;
r.read_sensor(0); // 综合考虑前方两个数值
r.read_sensor(1, -1); // 读面向左侧，位置靠前（右侧）的传感器的数值
```
**很明显，执行这些语句之前你必须设定好你的机器人。也就是`r.setup()`**。

`SENSOR_COORDINATION_TYPE`定义了传感器如何协调两个传感器的值。当它为1的时候，你对某个方向的读值是它们的平均值，当它为2的时候，你对某个方向的读值是它们的最小值。你可以在任意地方设定这个值，更改仅对这之后对传感器的读取有效。**这不影响你对传感器的单独读取，也就是带两个参数的`r.read_sensor`。

你甚至可以调用`r.set_coordination_function([1个参数])`来定义自定义的处理函数。里面填写一个函数名，它必须接受2个参数，返回一个参数，且类型均为`int`。例如
```
int proc(int a, int b){
    return a > b ? a : b;
}

...
r.set_coordination_function(proc);
```
这段代码会使你通过`r.read_sensor`（一个参数的版本）读到的值是两个传感器的最大值。要取消这个更改，你只需要重新设定`SENSOR_COORDINATION_TYPE`的值即可。

--------------------


## 控制机械臂
首先请将机械臂连接到主板上绿色的电机接口。然后请设置机械臂的接口编号。例如，如果你插到了M1端口，那么请设置为1. 代码示例如下所示。然而你**不一定**要在调用`r.setup()`之前就设置它的值，尽管在这之前就统一赋值可能显得整洁一些。但很显然，**你必须要在启动机械臂之前为之赋值**。
```cpp
#include "robot.h"

robot r;
void setup(){
    MECHANIC_ARM_MOTOR_ID = 1;
    r.setup();
}
```
要开启，请调用`r.start_arm();`。要关闭，请调用`r.stop_arm();`。例如：
```
void setup(){
    ......
    r.start_arm();
    delay(1000);
    r.stop_arm();
}
```
如果你发现它的转速不合适，请在启动机械臂之前更改`MECHANIC_ARM_ROTATION_SPEED`的值。（也就是为它赋值。）
如果你已经启动了机械臂，则只有下次启动机械臂时，机械臂才会以这个速度旋转。
例如：
```
r.start_arm();
.......
r.stop_arm();

MECHANIC_ARM_ROTATION_SPEED = 20;
r.start_arm();
```

------------------------

# 示例 - 四方向自动避障机器人
*这部分内容可能已经过期。请根据实际情况阅读*

若要掌握此类库，最终实现“灭火”的目的，我们可以先从一个非“灭火”的简单例子开始。比如，我们可以先实现实现一个程序，使得机器人可以在轮流四个方向上行走，遇到障碍物则改变方向，我们需要考虑：
* 机器人在遇到障碍物时停止并且改变方向
* 机器人在应该尽可能的在撞到障碍物之前就停止
* 需要测量传感器的值，以确定距离传感器读到什么值的时候代表机器人距离障碍物已经很近了
* 控制机器人的速度，以减少机器人打滑/漂移/因惯性撞上

程序的基本思路可能是这样的：
* 建立机器人。开始运行软件。
* 初始化机器人。
* 遍历四个方向，对于每个方向：
  * 前进。直到机器人遇到障碍停止。
* 不断重复上述过程。

首先编写第一步
```cpp
// app.ino
#include "robot.h"
robot r;
quad_directional *motors;
void setup(){
    r.setup();
    motors = r.motor_group;
}
```
上面这一段代码建立了程序的结构。`r.setup()`初始化了机器人。
`motors=r.motor_group`获取了机器人四个方向行进的控制器，也就是前文提到的`quad_directional`对象。尽管暂时用不到`motors`，我们可以先保留备用。当然不在此时保存`motors`对象也是可以的。你可以随时通过 `r.motor_group`获取它。  
**`r.motor_group`是一个变量，它没有`()`，因为它不是一个函数。对`r.motor_group`赋值可能带来不可预料的结果**

> ## 对`quad_directional`更深一层的解释
> `quad_directional`可以由两个`motor_pair`创建，前者代表四个轮子，
> 后者代表两个轮子。而**每个** `motor_pair` 可以由两个`motor_controller`创建。  
> 要创建一个`motor_controller`，首先要获得它在主板上的模拟端口号。配合L298(N)驱动器，每个电机需要2个模拟端口，然而主板上的端口数量不足以支撑4个电机，因此我们将其中一个模拟端口插到数字端口(digital pin)上以获得0或255。`motor_controller`就是为这种情况设计的。
> `motor_controller`的构造函数接受两个`int`参数，第一个代表模拟端口，第二个代表数字端口。假设它们分别是1和20，则
> ```cpp
> motor_controller motor_l(1, 20);
> ```
> 或
> ```cpp
> motor_controller *motor_lptr = new motor_controller(1, 20);
> ```
> 按照这种方式我们再获得另一个电机`*motor_rptr`，然后可以创建一个`motor_pair`对象。
> 在创建 `motor_pair` 对象之前，应该先确保这两个电机在接受相同值的情况下转动方向是一致的。如果不一致，则应该交换模拟端口和数字端口。  
> `motor_pair`的构造函数接受两个`motor_controller *`（指针）作为参数，分别代表以相同旋转方向的两个电机旋转方向为前方，左侧的电机和右侧的电机。其具体控制方式请见前面的API说明（可能还没写）。
> `quad_directional`的构造函数接受四个参数，分别为`(motor_pair *lr, direction dir_lr, motor_pair *fb, direcion dir_fb)`。`lr`, `fb`是两个电机对(`motor_pair`)，`dir_lr`和`dir_fb`代表两个电机对的速度为**正值**时电机的转动方向。否则`quad_directional`的方向设定功能会出现问题。

在`loop`函数（上面还未写出）中，首先遍历所有方向
```cpp
for(int i = 0; i < 4; i++){
    direction d = (direction) i;
}
```
这里我们使用了强制类型转换，因为direction中所定义的四个方向其实际值分别按照定义的顺序是0, 1, 2, 3，所以将0-3这四个数强制转换成direction类型就可以得到它们四个值。如果你不明白这是怎么运作的，请学习C++中的枚举(`enum`, Enumeration).  
接下来我们投机取巧，使用`r.move_until_blocked`函数来使机器人在遇到障碍时停止。
```cpp
for(int i = 0; i < 4; i++){
    direction d = (direction) i;
    r.move_until_blocked(d);
}
```
然而不要忘记我们需要控制机器人的速度以防止它因为过快而不能及时停止，所以还要在之前加上`robot.set_max_power(120)`。
于是我们就基本完成了。代码如下
```cpp
#include "robot.h"
robot r;
void setup(){
    r.setup();
    r.set_max_power(120);
}
void loop(){
    for(int i = 0; i < 4; i++){
        direction d = (direction) i;
        r.move_until_blocked(d);
    }
}
```
然而你也可能想实现自己的`move_until_blocked`函数。那我们可以这么写：
```cpp
void move_until_blocked(direction d){
    r.set_direction(d);
    r.go();
     // 更改下面这个60来测试机器人到底在什么位置停止比较合适
    while(r.read_sensor(d) > 60)
        ; //不要忘记这个分号
    r.stop();
}
```
只需要把`loop`函数中的`r.move_until_blocked(d)` 换成 `move_until_blocked(d)`，并且把它放在 `void setup(){...`之前就可以了。

这么做简单明朗。然而如果你观察`r.move_until_blocked`的定义，你会发现还是少了一些东西。你可以试着找出缺少了什么，并且描述一下这些缺少的部分起到了什么样的功能。
